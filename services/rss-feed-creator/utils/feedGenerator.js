
/**
 * feedGenerator.js
 * Builds and uploads a W3C-valid RSS 2.0 feed using rewritten articles.
 * Merges new items with existing feed items, respecting FEED_RETENTION_DAYS.
 */

import crypto from "crypto";
import { XMLBuilder } from "fast-xml-parser";
import { r2Put, r2Get } from "../../shared/utils/r2-client.js";
import { info, error ,debug} from "../../../logger.js";

const FEED_RETENTION_DAYS = Number(process.env.FEED_RETENTION_DAYS) || 7; // default 7 days

export async function generateFeed(bucket, rewrittenItems) {
  try {
    if (!Array.isArray(rewrittenItems) || rewrittenItems.length === 0) {
      debug("rss-feed-creator.generateFeed.skip", { reason: "no items" });
      return;
    }

    const now = new Date();
    const buildDate = now.toUTCString();
    const retentionCutoff = new Date(now.getTime() - FEED_RETENTION_DAYS * 24 * 60 * 60 * 1000);

    const channelTitle =
      process.env.RSS_FEED_TITLE?.trim() || "Turing's Torch: AI Weekly";
    const channelLink = "https://jonathan-harris.online";
    const channelDesc =
      process.env.RSS_FEED_DESCRIPTION?.trim() ||
      "AI insights and rewritten articles generated by Jonathan Harris's AI Podcast Suite.";

    // Load existing feed items from R2
    const existingItems = await loadExistingFeedItems(bucket);

    // Normalize new items (HARD: only publish items with a valid rewritten summary)
    const newItems = rewrittenItems
      .filter((x) => x && typeof x === "object")
      .map((item) => normalizeItem(item, channelLink, now))
      .filter((it) => isPublishable(it));

    // Merge existing and new items, deduplicate by link or guid
    const mergedItems = mergeAndDeduplicateItems(existingItems, newItems);

    // Filter by retention period
    const validItems = mergedItems.filter((item) => 
      isWithinRetention(item.pubDate, retentionCutoff)
    );

    // Sort by pubDate descending (newest first)
    validItems.sort((a, b) => new Date(b.pubDate) - new Date(a.pubDate));

    const totalBeforeRetention = mergedItems.length;
    const discardedCount = totalBeforeRetention - validItems.length;

    if (validItems.length === 0) {
      debug("rss-feed-creator.generateFeed.skip", { 
        reason: "no items within retention period",
        retentionDays: FEED_RETENTION_DAYS,
        discarded: discardedCount
      });
      return;
    }

    const feedObj = {
      rss: {
        "@_version": "2.0",
        "@_xmlns:atom": "http://www.w3.org/2005/Atom",
        channel: {
          title: escapeXml(channelTitle),
          link: channelLink,
          description: escapeXml(channelDesc),
          language: "en-gb",
          lastBuildDate: buildDate,
          pubDate: buildDate,
          generator: "AI Podcast Suite - RSS Feed Creator",
          "atom:link": {
            "@_href": `${channelLink}/feed.xml`,
            "@_rel": "self",
            "@_type": "application/rss+xml"
          },
          item: validItems.map((it) => ({
            title: escapeXml(it.title || "Untitled Article"),
            link: it.link,
            guid: { "@_isPermaLink": "false", "#text": it.guid },
            pubDate: it.pubDate,
            description: {
              __cdata: buildDescriptionHtml(it.title, it.rewritten, it.link),
            },
          })),
        },
      },
    };

    const builder = new XMLBuilder({
      format: true,
      ignoreAttributes: false,
      suppressEmptyNode: true,
      cdataPropName: "__cdata",
    });

    const xmlString =
      '<?xml version="1.0" encoding="UTF-8"?>\n' + builder.build(feedObj);
    const jsonString = JSON.stringify(feedObj, null, 2);

    await r2Put(bucket, "feed.xml", xmlString, "application/rss+xml");
    await r2Put(bucket, "feed.json", jsonString, "application/json");
    
    info("üìù rss-feed-creator.generateFeed.success")
    debug("üìù rss-feed-creator.generateFeed.success", {
      bucket,
      existingItems: existingItems.length,
      newItems: newItems.length,
      totalItems: validItems.length,
      discarded: discardedCount,
      retentionDays: FEED_RETENTION_DAYS,
      size: xmlString.length,
    });
  } catch (err) {
    error("rss-feed-creator.generateFeed.fail", err, { bucket });
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Helpers
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async function loadExistingFeedItems(bucket) {
  try {
    const jsonContent = await r2Get(bucket, "feed.json");
    if (!jsonContent) return [];

    const feedData = JSON.parse(jsonContent);
    const items = feedData?.rss?.channel?.item || [];
    
    // Convert back to our internal format
    return (Array.isArray(items) ? items : [items]).map((item) => ({
      title: item.title || "Untitled Article",
      link: item.link || "",
      pubDate: item.pubDate || new Date().toUTCString(),
      guid: item.guid?.["#text"] || item.guid || "",
      rewritten: extractTextFromCDATA(item.description?.__cdata || ""),
    }));
  } catch (err) {
    info("rss-feed-creator.loadExisting.fail", { 
      bucket, 
      reason: err.message,
      note: "Starting with empty feed" 
    });
    return [];
  }
}

function extractTextFromCDATA(cdataHtml) {
  // Extract content between <strong> tags and before <a> tag
  try {
    const match = cdataHtml.match(/<strong>.*?<\/strong><br\/><br\/>(.*?)<br\/><br\/>/s);
    return match ? match[1].trim() : cdataHtml;
  } catch {
    return cdataHtml;
  }
}

function mergeAndDeduplicateItems(existingItems, newItems) {
  const itemMap = new Map();
  
  // Add existing items first
  for (const item of existingItems) {
    const key = item.link || item.guid;
    if (key) {
      itemMap.set(key, item);
    }
  }
  
  // Add/overwrite with new items (new items take precedence)
  for (const item of newItems) {
    const key = item.link || item.guid;
    if (key) {
      itemMap.set(key, item);
    }
  }
  
  return Array.from(itemMap.values());
}

function isWithinRetention(pubDateStr, cutoffDate) {
  try {
    const itemDate = new Date(pubDateStr);
    if (isNaN(itemDate.getTime())) return false;
    
    // Keep items that are newer than the cutoff and not in the future
    return itemDate >= cutoffDate && itemDate <= new Date();
  } catch {
    return false;
  }
}

function normalizeItem(item, fallbackLink, now) {
  const title = item?.shortTitle || item?.title || "Untitled Article";
  const link = normalizeUrl(item?.shortUrl || item?.link || fallbackLink);
  
  // Parse pubDate and keep as ISO string for easier comparison
  let pubDate;
  try {
    const d = item?.pubDate ? new Date(item.pubDate) : now;
    pubDate = isNaN(d.getTime()) ? now.toUTCString() : d.toUTCString();
  } catch {
    pubDate = now.toUTCString();
  }

  // Use existing GUID if available, otherwise generate new one
  let guid = item?.guid;
  if (!guid) {
    const randomId = parseInt(crypto.randomBytes(6).toString("hex"), 16)
      .toString(36)
      .slice(0, 12);
    guid = `ai-news-${randomId}`;
  }

  // HARD: publish rewritten only (never fall back to source summary)
  const rewritten = String(item?.rewritten || "").trim();

  return { title, link, pubDate, guid, rewritten };
}

function buildDescriptionHtml(title, rewrittenHtml, link) {
  // Inside CDATA we can include simple HTML; keep title escaped for HTML
  const safeTitle = escapeHtml(title);
  const body = (rewrittenHtml || "").trim();
  const safeLink = escapeHtml(link);
  const anchor = `<a href="${safeLink}">Read on Jonathan-Harris RSS Feed</a>`;
  return `<strong>${safeTitle}</strong><br/><br/>${body}<br/><br/>${anchor}`;
}

function isPublishable(item) {
  const rewritten = String(item?.rewritten || "").trim();
  if (!rewritten) return false;
  if (rewritten === "REWRITE_ABORTED") return false;
  if (rewritten.startsWith("‚ö†Ô∏è")) return false;
  // Guard against accidental full HTML dumps
  if (/<[^>]+>/.test(rewritten)) return false;
  // Guard against ultra-short junk
  if (rewritten.length < 120) return false;
  return true;
}

function normalizeUrl(url = "") {
  try {
    const u = new URL(url);
    // Normalize host to lowercase to avoid mixed-case hosts
    u.host = u.host.toLowerCase();
    // Ensure https scheme
    if (u.protocol !== "https:") u.protocol = "https:";
    return u.href;
  } catch {
    return "";
  }
}

function escapeHtml(str = "") {
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function escapeXml(str = "") {
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}
